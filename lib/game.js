// Generated by CoffeeScript 1.9.3
var Game, color, colors, k, step,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

colors = [];

step = Math.floor(16777215 / 20);

for (color = k = 1; k <= 20; color = ++k) {
  colors.push("#" + (step * color).toString(16));
}

Game = (function() {
  function Game(canvas) {
    this.canvas = canvas;
    this.resize = bind(this.resize, this);
    this.mousedown = bind(this.mousedown, this);
    this.mouseup = bind(this.mouseup, this);
    this.tick = bind(this.tick, this);
    this.dragging = null;
    this.offset = [0, 0];
    this.lastmouse = [0, 0];
    this.board = new Board();
    this.ctx = this.canvas.getContext("2d");
    this.render = this.default_render;
    this.touch = Modernizr.touch;
    this.resize();
    this.interval_time = 6000;
    this.tick();
    window.addEventListener("resize", this.resize);
    this.canvas.addEventListener((this.touch ? "touchstart" : "mousedown"), this.mousedown);
    this.canvas.addEventListener((this.touch ? "touchend" : "mouseup"), this.mouseup);
    if (this.touch) {
      window.addEventListener("touchstart", function(e) {
        return e.preventDefault();
      });
    }
  }

  Game.prototype.tick = function() {
    this.board.add_pieces();
    this.render();
    if (this.lost()) {
      return alert("You lose");
    } else {
      this.interval_time *= 0.99;
      return setTimeout(this.tick, this.interval_time);
    }
  };

  Game.prototype.lost = function() {
    var col, l, len, ref;
    ref = this.board.cols;
    for (l = 0, len = ref.length; l < len; l++) {
      col = ref[l];
      if (col.length > this.board.size.rows - 1) {
        return true;
      }
    }
    return false;
  };

  Game.prototype.event_coord = function(e) {
    var col, left, ref, row, top, x, y;
    ref = this.translated_touch(e), x = ref[0], y = ref[1];
    left = x - this.offset[0];
    top = this.height - (y - this.offset[1]);
    col = Math.floor(left / this.scale);
    row = Math.floor(top / this.scale);
    return [col, row];
  };

  Game.prototype.mouseup = function(e) {
    var col, l, m, piece, ref, ref1, ref2, row, x, y;
    e.preventDefault();
    ref = this.event_coord(e), col = ref[0], row = ref[1];
    if (this.board.cols[col][row]) {
      piece = this.board.cols[col][row];
      if (piece.matches(this.dragging)) {
        piece.value++;
        if (piece.value > this.board.max) {
          this.board.max = piece.value;
        }
        for (x = l = 0, ref1 = this.board.cols.length - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; x = 0 <= ref1 ? ++l : --l) {
          for (y = m = 0, ref2 = this.board.cols[x].length - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; y = 0 <= ref2 ? ++m : --m) {
            if (this.board.cols[x][y] === this.dragging) {
              this.board.cols[x].splice(y, 1);
            }
          }
        }
      }
    }
    this.canvas.removeEventListener((this.touch ? "touchmove" : "mousemove"), this.render);
    if (this.dragging) {
      this.dragging.dragging = false;
      this.dragging = null;
    }
    this.render = this.default_render;
    return this.render();
  };

  Game.prototype.translated_touch = function(e) {
    if (e.targetTouches && e.targetTouches[0]) {
      return [e.targetTouches[0].pageX, e.targetTouches[0].pageY];
    } else if (e.pageX) {
      return [e.pageX, e.pageY];
    } else {
      return this.lastmouse;
    }
  };

  Game.prototype.mousedown = function(e) {
    var col, left, piece, ref, ref1, row, top, x, y;
    e.preventDefault();
    ref = this.event_coord(e), col = ref[0], row = ref[1];
    if (this.board.cols[col][row]) {
      piece = this.board.cols[col][row];
      piece.dragging = true;
      this.dragging = piece;
      ref1 = this.translated_touch(e), x = ref1[0], y = ref1[1];
      left = (x - this.offset[0]) % this.scale;
      top = (y - this.offset[1]) % this.scale;
      this.render = this.dragging_render(left, top);
      return this.canvas.addEventListener((this.touch ? "touchmove" : "mousemove"), this.render);
    }
  };

  Game.prototype.resize = function() {
    var ref, ref1, scalex, scaley;
    scaley = parseInt(window.innerHeight / this.board.size.rows);
    scalex = parseInt(window.innerWidth / this.board.size.cols);
    if (window.innerWidth > window.innerHeight) {
      if (scaley * this.board.size.cols <= window.innerWidth) {
        this.scale = scaley;
      } else {
        this.scale = scalex;
      }
    } else {
      if (scalex * this.board.size.rows <= window.innerHeight) {
        this.scale = scalex;
      } else {
        this.scale = scaley;
      }
    }
    ref = [this.board.size.cols * this.scale, this.board.size.rows * this.scale], this.width = ref[0], this.height = ref[1];
    ref1 = [this.width, this.height], this.canvas.width = ref1[0], this.canvas.height = ref1[1];
    this.offset = [this.canvas.offsetLeft, this.canvas.offsetTop];
    return this.render();
  };

  Game.prototype.clear = function() {
    this.ctx.fillStyle = "#fff";
    return this.ctx.fillRect(0, 0, this.width, this.height);
  };

  Game.prototype.draw_grid = function() {
    var grid, l, m, ref, ref1, results, x, y;
    this.ctx.strokeStyle = "#eee";
    this.ctx.lineWidth = 1;
    for (grid = l = 0, ref = this.board.size.rows; 0 <= ref ? l <= ref : l >= ref; grid = 0 <= ref ? ++l : --l) {
      y = grid * this.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, y);
      this.ctx.lineTo(this.width, y);
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = "#eee";
      this.ctx.stroke();
    }
    results = [];
    for (grid = m = 0, ref1 = this.board.size.cols; 0 <= ref1 ? m <= ref1 : m >= ref1; grid = 0 <= ref1 ? ++m : --m) {
      x = grid * this.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(x, 0);
      this.ctx.lineTo(x, this.height);
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = "#eee";
      results.push(this.ctx.stroke());
    }
    return results;
  };

  Game.prototype.dragging_render = function(offset_left, offset_top) {
    return (function(_this) {
      return function(e) {
        var left, top;
        _this.default_render();
        if (e) {
          _this.lastmouse = _this.translated_touch(e);
        }
        if (_this.dragging) {
          left = _this.lastmouse[0] - _this.offset[0];
          top = _this.lastmouse[1] - _this.offset[1];
          return _this.draw_tile(_this.dragging, left - offset_left, top - offset_top);
        }
      };
    })(this);
  };

  Game.prototype.draw_tile = function(piece, x, y) {
    this.ctx.fillStyle = colors[piece.value];
    this.ctx.fillRect(x, y, this.scale, this.scale);
    this.ctx.strokeRect(x, y, this.scale, this.scale);
    this.ctx.fillStyle = "#fff";
    return this.ctx.fillText(piece.value, x + (this.scale / 2), y + (this.scale / 2));
  };

  Game.prototype.default_render = function() {
    var i, j, l, piece, ref, results, x, y;
    this.clear();
    this.draw_grid();
    this.ctx.font = (this.scale * 0.66) + "px sans-serif";
    this.ctx.strokeStyle = "#eee";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    results = [];
    for (i = l = 0, ref = this.board.cols.length - 1; 0 <= ref ? l <= ref : l >= ref; i = 0 <= ref ? ++l : --l) {
      if (this.board.cols[i].length) {
        results.push((function() {
          var m, ref1, results1;
          results1 = [];
          for (j = m = 0, ref1 = this.board.cols[i].length - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; j = 0 <= ref1 ? ++m : --m) {
            piece = this.board.cols[i][j];
            if (!piece.dragging) {
              x = i * this.scale;
              y = this.height - (j * this.scale) - this.scale;
              results1.push(this.draw_tile(piece, x, y));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return Game;

})();
