// Generated by CoffeeScript 1.9.3
var Game, color, colors, k, step,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

colors = [];

step = Math.floor(16777215 / 20);

for (color = k = 1; k <= 20; color = ++k) {
  colors.push("#" + (step * color).toString(16));
}

Game = (function() {
  function Game(canvas) {
    this.canvas = canvas;
    this.resize = bind(this.resize, this);
    this.mousedown = bind(this.mousedown, this);
    this.mouseup = bind(this.mouseup, this);
    this.tick = bind(this.tick, this);
    this.dragging = null;
    this.lastmouse = [0, 0];
    this.board = new Board();
    this.ctx = this.canvas.getContext("2d");
    this.render = this.default_render;
    this.resize();
    this.interval_time = 5000;
    this.tick();
    $(window).on("resize", this.resize);
    $(this.canvas).on("mousedown touchstart", this.mousedown);
    $(this.canvas).on("mouseup touchend", this.mouseup);
  }

  Game.prototype.tick = function() {
    this.board.add_pieces();
    this.render();
    if (this.lost()) {
      return alert("You lose");
    } else {
      this.interval_time *= 0.95;
      return setTimeout(this.tick, this.interval_time);
    }
  };

  Game.prototype.lost = function() {
    var col, l, len, ref;
    ref = this.board.cols;
    for (l = 0, len = ref.length; l < len; l++) {
      col = ref[l];
      if (col.length > this.board.size.rows - 1) {
        return true;
      }
    }
    return false;
  };

  Game.prototype.event_coord = function(e) {
    var col, left, offset, ref, row, top, x, y;
    offset = $(this.canvas).offset();
    ref = this.translated_touch(e), x = ref[0], y = ref[1];
    left = x - offset.left;
    top = this.height - (y - offset.top);
    col = Math.floor(left / this.scale);
    row = Math.floor(top / this.scale);
    return [col, row];
  };

  Game.prototype.mouseup = function(e) {
    var col, l, m, piece, ref, ref1, ref2, row, x, y;
    e.preventDefault();
    ref = this.event_coord(e), col = ref[0], row = ref[1];
    if (this.board.cols[col][row]) {
      piece = this.board.cols[col][row];
      if (piece.matches(this.dragging)) {
        piece.value++;
        if (piece.value > this.max) {
          this.max = piece.value;
        }
        for (x = l = 0, ref1 = this.board.cols.length - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; x = 0 <= ref1 ? ++l : --l) {
          for (y = m = 0, ref2 = this.board.cols[x].length - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; y = 0 <= ref2 ? ++m : --m) {
            if (this.board.cols[x][y] === this.dragging) {
              this.board.cols[x].splice(y, 1);
            }
          }
        }
      }
    }
    $(this.canvas).off("mousemove");
    if (this.dragging) {
      this.dragging.dragging = false;
      this.dragging = null;
    }
    this.render = this.default_render;
    return this.render();
  };

  Game.prototype.translated_touch = function(e) {
    if (e.pageX) {
      return [e.pageX, e.pageY];
    } else if (e.targetTouches) {
      return [e.targetTouches[0].pageX, e.targetTouches[0].pageY];
    }
  };

  Game.prototype.mousedown = function(e) {
    var col, left, offset, piece, ref, ref1, row, top, x, y;
    e.preventDefault();
    ref = this.event_coord(e), col = ref[0], row = ref[1];
    if (this.board.cols[col][row]) {
      piece = this.board.cols[col][row];
      piece.dragging = true;
      this.dragging = piece;
      ref1 = this.translated_touch(e), x = ref1[0], y = ref1[1];
      offset = $(this.canvas).offset();
      left = (x - offset.left) % this.scale;
      top = (y - offset.top) % this.scale;
      this.render = this.dragging_render(left, top);
      return $(this.canvas).on("mousemove", this.render);
    }
  };

  Game.prototype.resize = function() {
    var ref;
    this.scale = parseInt(Math.min(window.innerWidth, window.innerHeight) / Math.max(this.board.size.rows, this.board.size.cols));
    ref = [this.board.size.cols * this.scale, this.board.size.rows * this.scale], this.width = ref[0], this.height = ref[1];
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    return this.render();
  };

  Game.prototype.clear = function() {
    this.ctx.fillStyle = "#fff";
    return this.ctx.fillRect(0, 0, this.width, this.height);
  };

  Game.prototype.draw_grid = function() {
    var grid, l, m, ref, ref1, results, x, y;
    this.ctx.strokeStyle = "#eee";
    this.ctx.lineWidth = 1;
    for (grid = l = 0, ref = this.board.size.rows; 0 <= ref ? l <= ref : l >= ref; grid = 0 <= ref ? ++l : --l) {
      y = grid * this.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, y);
      this.ctx.lineTo(this.width, y);
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = "#eee";
      this.ctx.stroke();
    }
    results = [];
    for (grid = m = 0, ref1 = this.board.size.cols; 0 <= ref1 ? m <= ref1 : m >= ref1; grid = 0 <= ref1 ? ++m : --m) {
      x = grid * this.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(x, 0);
      this.ctx.lineTo(x, this.height);
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = "#eee";
      results.push(this.ctx.stroke());
    }
    return results;
  };

  Game.prototype.dragging_render = function(offset_left, offset_top) {
    return (function(_this) {
      return function(e) {
        var left, offset, top;
        _this.default_render();
        if (e) {
          _this.lastmouse = _this.translated_touch(e);
        }
        if (_this.dragging) {
          offset = $(_this.canvas).offset();
          left = _this.lastmouse[0] - offset.left;
          top = _this.lastmouse[1] - offset.top;
          return _this.draw_tile(_this.dragging, left - offset_left, top - offset_top);
        }
      };
    })(this);
  };

  Game.prototype.draw_tile = function(piece, x, y) {
    this.ctx.fillStyle = colors[piece.value];
    this.ctx.fillRect(x, y, this.scale, this.scale);
    this.ctx.strokeRect(x, y, this.scale, this.scale);
    this.ctx.fillStyle = "#fff";
    return this.ctx.fillText(piece.value, x + (this.scale / 2), y + (this.scale / 2));
  };

  Game.prototype.default_render = function() {
    var i, j, l, piece, ref, results, x, y;
    this.clear();
    this.draw_grid();
    this.ctx.font = (this.scale * 0.66) + "px sans-serif";
    this.ctx.strokeStyle = "#eee";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    results = [];
    for (i = l = 0, ref = this.board.cols.length - 1; 0 <= ref ? l <= ref : l >= ref; i = 0 <= ref ? ++l : --l) {
      if (this.board.cols[i].length) {
        results.push((function() {
          var m, ref1, results1;
          results1 = [];
          for (j = m = 0, ref1 = this.board.cols[i].length - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; j = 0 <= ref1 ? ++m : --m) {
            piece = this.board.cols[i][j];
            if (!piece.dragging) {
              x = i * this.scale;
              y = this.height - (j * this.scale) - this.scale;
              results1.push(this.draw_tile(piece, x, y));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return Game;

})();
