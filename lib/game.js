// Generated by CoffeeScript 1.9.3
var Game, color, colors, k, step,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

colors = [];

step = Math.floor(16777215 / 20);

for (color = k = 1; k <= 20; color = ++k) {
  colors.push("#" + (step * color).toString(16));
}

Game = (function() {
  function Game(canvas) {
    this.canvas = canvas;
    this.resize = bind(this.resize, this);
    this.mousedown = bind(this.mousedown, this);
    this.mouseup = bind(this.mouseup, this);
    this.tick = bind(this.tick, this);
    this.match = null;
    this.dragging = null;
    this.dragging_offset = {
      x: 0,
      y: 0
    };
    this.dirty_drag = false;
    this.dirty_drag_reset = null;
    this.board = new Board();
    this.ctx = this.canvas.getContext("2d");
    this.render = this.default_render;
    this.touch = Modernizr.touch;
    this.resize();
    this.interval_time = 6000;
    this.tick();
    window.addEventListener("resize", this.resize);
    this.canvas.addEventListener((this.touch ? "touchstart" : "mousedown"), this.mousedown);
    this.canvas.addEventListener((this.touch ? "touchend" : "mouseup"), this.mouseup);
    if (this.touch) {
      window.addEventListener("touchstart", function(e) {
        return e.preventDefault();
      });
    }
  }

  Game.prototype.tick = function() {
    this.board.add_pieces();
    this.render();
    if (this.lost()) {
      return alert("You lose");
    } else {
      this.interval_time *= 0.99;
      return setTimeout(this.tick, this.interval_time);
    }
  };

  Game.prototype.lost = function() {
    var col, l, len, ref;
    ref = this.board.cols;
    for (l = 0, len = ref.length; l < len; l++) {
      col = ref[l];
      if (col.length > this.board.size.rows - 1) {
        return true;
      }
    }
    return false;
  };

  Game.prototype.coord_index = function(pos) {
    var col, left, row, top;
    left = pos.x - this.dragging_offset.x;
    top = this.height - (pos.y - this.dragging_offset.y);
    left = Math.min(Math.max(left), this.width);
    top = Math.min(Math.max(top), this.height);
    col = Math.floor(left / this.scale);
    row = Math.floor(top / this.scale);
    return [col, row];
  };

  Game.prototype.mouseup = function(e) {
    var col, l, m, piece, ref, ref1, ref2, row, x, y;
    e.preventDefault();
    ref = this.coord_index(this.translated_touch(e)), col = ref[0], row = ref[1];
    if (this.board.cols[col][row]) {
      this.board.cols[col][row].is_match = false;
      this.board.cols[col][row].is_miss = false;
    }
    if (this.dirty_drag) {
      this.dirty_drag = false;
      this.dirty_drag_reset = null;
    } else if (this.board.cols[col][row]) {
      piece = this.board.cols[col][row];
      if (piece.matches(this.dragging)) {
        piece.value++;
        if (piece.value > this.board.max) {
          this.board.max = piece.value;
        }
        for (x = l = 0, ref1 = this.board.cols.length - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; x = 0 <= ref1 ? ++l : --l) {
          for (y = m = 0, ref2 = this.board.cols[x].length - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; y = 0 <= ref2 ? ++m : --m) {
            if (this.board.cols[x][y] === this.dragging) {
              this.board.cols[x].splice(y, 1);
            }
          }
        }
      }
    }
    this.canvas.removeEventListener((this.touch ? "touchmove" : "mousemove"), this.render);
    if (this.dragging) {
      this.dragging.dragging = false;
      this.dragging.is_miss = false;
      this.dragging.is_match = false;
      this.dragging = null;
    }
    this.render = this.default_render;
    return this.render();
  };

  Game.prototype.translated_touch = function(e) {
    if (e.targetTouches && e.targetTouches[0]) {
      return {
        x: e.targetTouches[0].pageX,
        y: e.targetTouches[0].pageY
      };
    } else if (e.pageX) {
      return {
        x: e.pageX,
        y: e.pageY
      };
    }
  };

  Game.prototype.mousedown = function(e) {
    var col, left, piece, ref, row, top;
    e.preventDefault();
    ref = this.coord_index(this.translated_touch(e)), col = ref[0], row = ref[1];
    if (this.board.cols[col][row]) {
      piece = this.board.cols[col][row];
      piece.dragging = true;
      this.dragging = piece;
      this.dragging.pos = this.translated_touch(e);
      left = (this.dragging.pos.x - this.dragging_offset.x) % this.scale;
      top = (this.dragging.pos.y - this.dragging_offset.y) % this.scale;
      this.render = this.dragging_render(left, top);
      return this.canvas.addEventListener((this.touch ? "touchmove" : "mousemove"), this.render);
    }
  };

  Game.prototype.resize = function() {
    var ref, ref1, scalex, scaley;
    scaley = parseInt(window.innerHeight / this.board.size.rows);
    scalex = parseInt(window.innerWidth / this.board.size.cols);
    if (window.innerWidth > window.innerHeight) {
      if (scaley * this.board.size.cols <= window.innerWidth) {
        this.scale = scaley;
      } else {
        this.scale = scalex;
      }
    } else {
      if (scalex * this.board.size.rows <= window.innerHeight) {
        this.scale = scalex;
      } else {
        this.scale = scaley;
      }
    }
    ref = [this.board.size.cols * this.scale, this.board.size.rows * this.scale], this.width = ref[0], this.height = ref[1];
    ref1 = [this.width, this.height], this.canvas.width = ref1[0], this.canvas.height = ref1[1];
    this.dragging_offset = {
      x: this.canvas.offsetLeft,
      y: this.canvas.offsetTop
    };
    return this.render();
  };

  Game.prototype.clear = function() {
    this.ctx.fillStyle = "#fff";
    return this.ctx.fillRect(0, 0, this.width, this.height);
  };

  Game.prototype.draw_grid = function() {
    var grid, l, m, ref, ref1, results, x, y;
    this.ctx.strokeStyle = "#eee";
    this.ctx.lineWidth = 1;
    for (grid = l = 0, ref = this.board.size.rows; 0 <= ref ? l <= ref : l >= ref; grid = 0 <= ref ? ++l : --l) {
      y = grid * this.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, y);
      this.ctx.lineTo(this.width, y);
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = "#eee";
      this.ctx.stroke();
    }
    results = [];
    for (grid = m = 0, ref1 = this.board.size.cols; 0 <= ref1 ? m <= ref1 : m >= ref1; grid = 0 <= ref1 ? ++m : --m) {
      x = grid * this.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(x, 0);
      this.ctx.lineTo(x, this.height);
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = "#eee";
      results.push(this.ctx.stroke());
    }
    return results;
  };

  Game.prototype.dragging_render = function(offset_left, offset_top) {
    return (function(_this) {
      return function(e) {
        var left, pos, top;
        _this.default_render();
        if (_this.dragging) {
          if (e) {
            pos = _this.translated_touch(e);
            if (_this.is_safe_pos(pos)) {
              _this.dirty_drag = false;
              _this.dragging.pos = pos;
            } else {
              _this.dirty_drag_reset = _this.coord_index(_this.dragging.pos);
              _this.dirty_drag = true;
            }
          }
          left = _this.dragging.pos.x - _this.dragging_offset.x;
          top = _this.dragging.pos.y - _this.dragging_offset.y;
          return _this.draw_tile(_this.dragging, left - offset_left, top - offset_top);
        }
      };
    })(this);
  };

  Game.prototype.is_safe_pos = function(pos) {
    var col, ref, row;
    ref = this.coord_index(pos), col = ref[0], row = ref[1];
    if (this.match) {
      this.dragging.is_match = false;
      this.dragging.is_miss = false;
      this.match.is_match = false;
      this.match.is_miss = false;
      this.match = null;
    }
    if (this.dirty_drag) {
      if (this.dirty_drag_reset[0] === col && this.dirty_drag_reset[1] === row) {
        return true;
      } else {
        return false;
      }
    }
    if (!this.board.cols[col][row] || this.board.cols[col][row] === this.dragging) {
      return true;
    }
    if (this.dragging.matches(this.board.cols[col][row])) {
      this.match = this.board.cols[col][row];
      this.match.is_match = true;
      this.dragging.is_match = true;
      return true;
    } else {
      this.board.cols[col][row].is_miss = true;
      this.dragging.is_miss = true;
    }
    return false;
  };

  Game.prototype.draw_tile = function(piece, x, y) {
    if (piece.is_match && !piece.dragging) {
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "#7fff00";
    } else if (piece.is_miss && !piece.dragging) {
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "red";
    } else {
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = "#eee";
    }
    if (piece.dragging && (piece.is_miss || piece.is_match)) {
      this.ctx.globalAlpha = 0.5;
    } else {
      this.ctx.globalAlpha = 1;
    }
    this.ctx.fillStyle = colors[piece.value];
    this.ctx.fillRect(x, y, this.scale, this.scale);
    this.ctx.strokeRect(x, y, this.scale, this.scale);
    this.ctx.fillStyle = "#fff";
    this.ctx.fillText(piece.value, x + (this.scale / 2), y + (this.scale / 2));
    return this.ctx.globalAlpha = 1;
  };

  Game.prototype.default_render = function() {
    var i, j, l, piece, ref, results, x, y;
    this.clear();
    this.draw_grid();
    this.ctx.font = (this.scale * 0.66) + "px sans-serif";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    results = [];
    for (i = l = 0, ref = this.board.cols.length - 1; 0 <= ref ? l <= ref : l >= ref; i = 0 <= ref ? ++l : --l) {
      if (this.board.cols[i].length) {
        results.push((function() {
          var m, ref1, results1;
          results1 = [];
          for (j = m = 0, ref1 = this.board.cols[i].length - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; j = 0 <= ref1 ? ++m : --m) {
            piece = this.board.cols[i][j];
            if (!piece.dragging) {
              x = i * this.scale;
              y = this.height - (j * this.scale) - this.scale;
              results1.push(this.draw_tile(piece, x, y));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return Game;

})();
